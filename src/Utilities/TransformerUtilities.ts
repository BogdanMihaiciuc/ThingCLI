import { TransformerStore, DiagnosticMessageKind, DiagnosticMessage, TWThingTransformer } from 'bm-thing-transformer';
import ts from "typescript";

/**
 * Handles firing any post transform actions of transformers and returns any found diagnostic messages
 * @param program Typescript program that was compiled
 * @param projectName Name of the project being compiled
 * @param store Store reference with all the com
 * @param emitResult Contents of the typescript emit result, if existing
 * @returns Any diagnostics messages found during the transforming process
 */
export function firePostTransformActions(program: ts.Program, store: TransformerStore, projectName: string, emitResult?: ts.EmitResult): { tsDiagnostics: string, validationDiagnostics: DiagnosticMessage[] } {
    let formattedDiagnostics = '';

    // Get and store all diagnostic messages generated by typescript to display them when the task finishes
    if (emitResult) {
        const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
        const defaultFormatHost: ts.FormatDiagnosticsHost = {
            getCurrentDirectory: () => ts.sys.getCurrentDirectory(),
            getCanonicalFileName: fileName => fileName,
            getNewLine: () => ts.sys.newLine
        };

        const formattedDiagnostics = ts.formatDiagnosticsWithColorAndContext(allDiagnostics, defaultFormatHost);

        // If an error causes a compilation failure, display the diagnostic messages and fail
        if (emitResult.emitSkipped) {
            process.stdout.write(`\r\x1b[1;31mâœ–\x1b[0m Failed building ${projectName || 'project'}\n`);

            console.log(formattedDiagnostics);

            throw new Error('Compilation failed.');
        }
    }

    // Handle any post transform actions, like validations and dataShape inheritance
    for (const key in store) {
        if (key.startsWith('@')) continue;

        const transformer = store[key] as TWThingTransformer;
        transformer.firePostTransformActions();
    }

    const diagnosticMessages: DiagnosticMessage[] = store['@diagnosticMessages'] || [];

    // If any errors were reported, display them and fail
    if (diagnosticMessages.some(m => m.kind == DiagnosticMessageKind.Error)) {
        process.stdout.write(`\r\x1b[1;31mâœ–\x1b[0m Failed building ${projectName || 'project'}\n`);

        for (const message of diagnosticMessages) {
            switch (message.kind) {
                case DiagnosticMessageKind.Error:
                    console.log(`ðŸ›‘ \x1b[1;31mError\x1b[0m ${message.message}`);
                    break;
                case DiagnosticMessageKind.Warning:
                    console.log(`ðŸ”¶ \x1b[1;33mWarning\x1b[0m ${message.message}`);
                    break;
            }
        }

        throw new Error('Validation failed.');
    }

    return {
        tsDiagnostics: formattedDiagnostics,
        validationDiagnostics: diagnosticMessages
    }
}